import {
  Button,
  Flex,
  FormControl,
  FormLabel,
  HStack,
  Icon,
  Input,
  Radio,
  RadioGroup,
  Switch,
  Text,
  useColorModeValue,
  useDisclosure,
  useToast,
  VStack,
} from '@chakra-ui/react'
import {
  PublicScheduleContext,
  ScheduleStateContext,
} from '@components/public-meeting'
import * as Tooltip from '@radix-ui/react-tooltip'
import { PublicSchedulingSteps } from '@utils/constants/meeting-types'
import { Select } from 'chakra-react-select'
import { useRouter } from 'next/router'
import { useContext, useEffect, useMemo, useState } from 'react'
import { FaInfo } from 'react-icons/fa'

import { ChipInput } from '@/components/chip-input'
import RichTextEditor from '@/components/profile/components/RichTextEditor'
import CancelComponent from '@/components/public-meeting/CancelComponent'
import { OnboardingModalContext } from '@/providers/OnboardingModalProvider'
import { AccountPreferences } from '@/types/Account'
import { MeetingReminders } from '@/types/common'
import {
  ParticipantInfo,
  ParticipantType,
  ParticipationStatus,
} from '@/types/ParticipantInfo'
import { guestMeetingCancel } from '@/utils/api_helper'
import { cancelMeetingGuest } from '@/utils/calendar_manager'
import {
  MeetingNotificationOptions,
  MeetingRepeatOptions,
} from '@/utils/constants/schedule'
import { noClearCustomSelectComponent } from '@/utils/constants/select'
import { MeetingNotFoundError, UnauthorizedError } from '@/utils/errors'
import { formatCurrency, renderProviderName } from '@/utils/generic_utils'
import { ellipsizeAddress } from '@/utils/user_manager'

import { AccountContext } from '../../../providers/AccountProvider'
import {
  MeetingDecrypted,
  MeetingProvider,
  SchedulingType,
} from '../../../types/Meeting'
import { isEmptyString, isValidEmail } from '../../../utils/validations'

interface ScheduleFormProps {
  pickedTime: Date
  isSchedulingExternal: boolean
  willStartScheduling?: (isScheduling: boolean) => void
  isGateValid?: boolean
  preferences?: AccountPreferences
  notificationsSubs?: number
}

export const ScheduleForm: React.FC<ScheduleFormProps> = ({
  pickedTime,
  isSchedulingExternal,
  willStartScheduling,
  isGateValid,
  notificationsSubs,
}) => {
  const { logged } = useContext(AccountContext)
  const {
    confirmSchedule,
    timezone,
    participants,
    setParticipants,
    meetingProvider,
    setMeetingProvider,
    meetingNotification,
    setMeetingNotification,
    meetingRepeat,
    setMeetingRepeat,
    content,
    setContent,
    name,
    setName,
    title,
    setTitle,
    doSendEmailReminders,
    setSendEmailReminders,
    scheduleType,
    setScheduleType,
    addGuest,
    setAddGuest,
    guestEmail,
    setGuestEmail,
    userEmail,
    setUserEmail,
    meetingUrl,
    setMeetingUrl,
    isFirstGuestEmailValid,
    setIsFirstGuestEmailValid,
    isFirstUserEmailValid,
    setIsFirstUserEmailValid,
    showEmailConfirm,
    setShowEmailConfirm,
    meetingSlotId,
    rescheduleSlot,
    setLastScheduledMeeting,
    setIsCancelled,
  } = useContext(ScheduleStateContext)
  const { tx, selectedType, setCurrentStep } = useContext(PublicScheduleContext)
  const toast = useToast()
  const router = useRouter()
  const query = router.query
  const { account } = useContext(PublicScheduleContext)
  const [isCancelling, setIsCancelling] = useState(false)
  const [reason, setReason] = useState('')
  const { metadata, conferenceId } = query
  const { isOpen, onClose, onOpen } = useDisclosure()
  const [autoGeneratedTitle, setAutoGeneratedTitle] = useState('')
  let meetingProviders = selectedType?.meeting_platforms || []
  const PROVIDERS = useMemo(() => {
    return [
      MeetingProvider.GOOGLE_MEET,
      MeetingProvider.ZOOM,
      MeetingProvider.HUDDLE,
      MeetingProvider.JITSI_MEET,
      MeetingProvider.CUSTOM,
    ]
  }, [])
  meetingProviders = meetingProviders.length > 0 ? meetingProviders : PROVIDERS

  const generateMeetingTitle = () => {
    if (!selectedType || !pickedTime || !name || !account) {
      return ''
    }

    const meetingTypeName = selectedType.title || 'Meeting'
    const guestName = name.trim()
    const hostName =
      account.preferences?.name || ellipsizeAddress(account.address)

    return `${meetingTypeName} between ${guestName} and ${hostName}`
  }

  useEffect(() => {
    if (selectedType?.custom_link) {
      setMeetingProvider(MeetingProvider.CUSTOM)
      setMeetingUrl(selectedType.custom_link)
    }
  }, [selectedType])
  const handleScheduleWithWallet = async () => {
    if (!logged && scheduleType === SchedulingType.REGULAR) {
      await handleScheduleType(SchedulingType.REGULAR)
    }
    if (!logged) return
    await handleConfirm()
  }
  useEffect(() => {
    if (logged) {
      setScheduleType(SchedulingType.REGULAR)
    } else {
      setScheduleType(SchedulingType.GUEST)
    }
  }, [logged, selectedType])

  useEffect(() => {
    if (title && title.trim() !== '') {
      setAutoGeneratedTitle('')
    }
  }, [])

  // Auto-generate meeting title when guest name changes
  useEffect(() => {
    if (meetingSlotId) {
      return
    }

    const generatedTitle = generateMeetingTitle()
    if (!generatedTitle && !name.trim()) {
      if (title === autoGeneratedTitle) {
        setTitle('')
        setAutoGeneratedTitle('')
      }
      return
    }
    if (title === '' || title === autoGeneratedTitle) {
      setTitle(generatedTitle)
      setAutoGeneratedTitle(generatedTitle)
    }
  }, [name, pickedTime, selectedType, timezone.value, account])

  useEffect(() => {
    if (rescheduleSlot && meetingSlotId) {
      if (rescheduleSlot.title) {
        setTitle(rescheduleSlot.title)
        setAutoGeneratedTitle('')
      }
      if (rescheduleSlot.reminders) {
        setMeetingNotification(
          rescheduleSlot.reminders.map(reminder => ({
            value: reminder,
            label:
              MeetingNotificationOptions.find(
                option => option.value === reminder
              )?.label || '',
          }))
        )
      }
      if (rescheduleSlot.provider) {
        setMeetingProvider(rescheduleSlot.provider || MeetingProvider.CUSTOM)
      }

      if (rescheduleSlot.recurrence) {
        setMeetingRepeat({
          value: rescheduleSlot.recurrence,
          label:
            MeetingRepeatOptions.find(
              option => option.value === rescheduleSlot.recurrence
            )?.label || '',
        })
      }
      if (rescheduleSlot.meeting_url) {
        setMeetingUrl(rescheduleSlot.meeting_url)
      }
      if (rescheduleSlot.participants) {
        const actor = rescheduleSlot.participants?.find(
          p => p.slot_id === meetingSlotId
        )
        if (actor) {
          setGuestEmail(actor.guest_email || '')
          setName(actor.name || '')
          setParticipants(
            rescheduleSlot.participants.filter(
              p => p.slot_id !== meetingSlotId && p.guest_email
            )
          )
        }
      }
    }
  }, [rescheduleSlot])

  const handleConfirm = async () => {
    const finalTitle = isEmptyString(title)
      ? generateMeetingTitle()
      : title.trim()

    if (meetingProvider === MeetingProvider.CUSTOM && !meetingUrl) {
      toast({
        title: 'Missing information',
        description: 'Please provide a meeting link for participants to join',
        status: 'error',
        duration: 5000,
        position: 'top',
        isClosable: true,
      })
      return
    }
    if (isNameEmpty) {
      toast({
        title: 'Missing information',
        description: 'Please fill in your name (or any identifier)',
        status: 'error',
        duration: 5000,
        position: 'top',
        isClosable: true,
      })
      return
    }
    if (scheduleType === SchedulingType.GUEST && !isGuestEmailValid()) {
      toast({
        title: 'Missing information',
        description:
          'Please provide a valid email to be able to schedule a meeting as guest',
        status: 'error',
        duration: 5000,
        position: 'top',
        isClosable: true,
      })
      return
    }
    if (doSendEmailReminders && !isValidEmail(userEmail)) {
      toast({
        title: 'Missing information',
        description:
          'Please provide a valid email address to send reminders to',
        status: 'error',
        duration: 5000,
        position: 'top',
        isClosable: true,
      })
      return
    }
    try {
      if (selectedType?.plan && !tx && !meetingSlotId) {
        setCurrentStep(PublicSchedulingSteps.PAY_FOR_SESSION)
      } else {
        const success = await confirmSchedule(
          scheduleType!,
          pickedTime,
          guestEmail,
          name,
          content,
          meetingUrl,
          doSendEmailReminders ? userEmail : undefined,
          finalTitle,
          participants,
          meetingProvider,
          meetingNotification.map(n => n.value as MeetingReminders),
          meetingRepeat.value,
          tx
        )

        willStartScheduling && willStartScheduling?.(!success)
      }
    } catch (_e) {
      willStartScheduling && willStartScheduling?.(true)
    }
  }
  const handleCancelMeeting = async () => {
    if (!meetingSlotId || !rescheduleSlot) return
    setIsCancelling(true)
    try {
      let response
      if (conferenceId) {
        response = await cancelMeetingGuest(
          rescheduleSlot as MeetingDecrypted,
          reason
        )
      } else {
        response = await guestMeetingCancel(meetingSlotId, {
          metadata: metadata as string,
          currentTimezone: timezone.value,
          reason,
        })
      }
      if (response) {
        setIsCancelled(true)
        const participants: Array<ParticipantInfo> =
          rescheduleSlot?.participants || []
        participants.push({
          account_address: account?.address,
          name: account.preferences?.name,
          type: ParticipantType.Owner,
          status: ParticipationStatus.Accepted,
          slot_id: '',
          meeting_id: '',
        })
        setLastScheduledMeeting({
          id: meetingSlotId,
          title: rescheduleSlot?.title || '',
          start: rescheduleSlot?.start || new Date(),
          end: rescheduleSlot?.end || new Date(),
          meeting_url: rescheduleSlot?.meeting_url || '',
          participants,
        } as unknown as MeetingDecrypted) // add only the needed properties; TODO: Define a custom type only with what's needed on the modal.
        onClose()
      }
    } catch (error) {
      if (error instanceof MeetingNotFoundError) {
        toast({
          title: 'Meeting not found',
          status: 'error',
          duration: 5000,
          isClosable: true,
          description: 'The meeting you are trying to cancel was not found',
        })
      } else if (error instanceof UnauthorizedError) {
        toast({
          title: 'Invalid Cancel Url',
          status: 'error',
          duration: 5000,
          isClosable: true,
          description: 'The cancel url is invalid',
        })
      } else if (error instanceof Error) {
        toast({
          title: 'Error cancelling meeting',
          status: 'error',
          duration: 5000,
          isClosable: true,
          description: error.message,
        })
      }
    }
    setIsCancelling(false)
  }
  const { openConnection } = useContext(OnboardingModalContext)

  const handleScheduleType = async (type: SchedulingType) => {
    setScheduleType(type)
    if (type === SchedulingType.REGULAR && !logged) {
      openConnection()
    }
  }

  const isGuestEmailValid = () => isValidEmail(guestEmail)
  const isUserEmailValid = () => isValidEmail(userEmail)
  const isNameEmpty = isEmptyString(name)

  const bgColor = useColorModeValue('white', 'gray.600')
  const iconColor = useColorModeValue('gray.600', 'white')

  const getScheduleButtonLabel = () => {
    if (isSchedulingExternal) return 'Scheduling...'
    if (logged || scheduleType === SchedulingType.GUEST) {
      if (selectedType?.plan && !tx && !meetingSlotId) {
        return `Continue to make payment (${formatCurrency(
          selectedType.plan.no_of_slot * selectedType.plan.price_per_slot
        )})`
      }
      return meetingSlotId ? 'Update Meeting' : 'Schedule'
    }
    return 'Connect Wallet to Schedule'
  }

  return (
    <Flex
      direction="column"
      gap={4}
      as={'form'}
      onSubmit={e => {
        e.preventDefault()
        handleConfirm()
      }}
      paddingTop={3}
      w="100%"
      maxW={{
        base: '100%',
        md: '550px',
      }}
    >
      {rescheduleSlot && (
        <CancelComponent
          isOpen={isOpen}
          onClose={onClose}
          isCancelling={isCancelling}
          handleCancelMeeting={handleCancelMeeting}
          meeting={rescheduleSlot}
          reason={reason}
          setReason={setReason}
          timezone={timezone.value}
        />
      )}
      <FormControl>
        <FormLabel>Your Name</FormLabel>
        <Input
          autoFocus
          type="text"
          isDisabled={isSchedulingExternal}
          placeholder="Your name or an identifier"
          value={name}
          onChange={e => setName(e.target.value)}
          onKeyDown={event => event.key === 'Enter' && handleConfirm()}
        />
      </FormControl>

      {(scheduleType === SchedulingType.GUEST || doSendEmailReminders) && (
        <FormControl
          isInvalid={
            doSendEmailReminders
              ? !isFirstUserEmailValid && !isUserEmailValid()
              : !isFirstGuestEmailValid && !isGuestEmailValid()
          }
        >
          <FormLabel>Email</FormLabel>
          <Input
            type="email"
            placeholder="Insert your email"
            isDisabled={isSchedulingExternal}
            value={doSendEmailReminders ? userEmail : guestEmail}
            onKeyDown={event => event.key === 'Enter' && handleConfirm()}
            borderColor={showEmailConfirm ? 'green.500' : undefined}
            onBlur={() => {
              setShowEmailConfirm(isGuestEmailValid())
            }}
            onChange={e => {
              if (doSendEmailReminders) {
                setUserEmail(e.target.value)
                setIsFirstUserEmailValid(false)
              } else {
                setGuestEmail(e.target.value)
                setIsFirstGuestEmailValid(false)
              }
            }}
          />
          {showEmailConfirm && (
            <Text
              color="green.500"
              fontSize="medium"
              mt={2}
              w="100%"
              textAlign={'left'}
            >
              Confirm you entered the correct email before you proceed
            </Text>
          )}
        </FormControl>
      )}

      {!addGuest ? (
        <Button
          bg="transparent"
          color="primary.200"
          _hover={{ bg: 'transparent' }}
          border="1px solid"
          borderColor="primary.200"
          borderRadius={8}
          onClick={() => setAddGuest(true)}
          py={2}
        >
          Add other participants
        </Button>
      ) : (
        <ChipInput
          currentItems={participants}
          placeholder="Enter participants"
          onChange={setParticipants}
          renderItem={p => {
            if (p.account_address) {
              return p.name || ellipsizeAddress(p.account_address!)
            } else if (p.name && p.guest_email) {
              return `${p.name} - ${p.guest_email}`
            } else if (p.name) {
              return `${p.name}`
            } else {
              return p.guest_email!
            }
          }}
        />
      )}

      <FormControl>
        <Flex
          alignItems="center"
          marginBottom="8px"
          marginRight="12px"
          gap="6px"
        >
          <FormLabel
            htmlFor="title"
            alignItems="center"
            height="fit-content"
            margin={0}
          >
            Meeting title
          </FormLabel>
          <Tooltip.Provider delayDuration={400}>
            <Tooltip.Root>
              <Tooltip.Trigger>
                <Flex
                  w="16px"
                  h="16px"
                  borderRadius="50%"
                  bgColor={iconColor}
                  justifyContent="center"
                  alignItems="center"
                  ml={1}
                >
                  <Icon w={1} color={bgColor} as={FaInfo} />
                </Flex>
              </Tooltip.Trigger>
              <Tooltip.Content>
                <Text
                  fontSize="sm"
                  p={2}
                  maxW="150px"
                  bgColor={bgColor}
                  shadow="lg"
                >
                  Give a title for your meeting
                </Text>
                <Tooltip.Arrow />
              </Tooltip.Content>
            </Tooltip.Root>
          </Tooltip.Provider>
        </Flex>
        <Input
          id="title"
          value={title}
          onChange={e => setTitle(e.target.value)}
          isDisabled={isSchedulingExternal}
          type="text"
          placeholder="Give a title for your meeting"
        />
      </FormControl>

      <FormControl w="100%" maxW="100%">
        <FormLabel>Meeting reminders (optional)</FormLabel>
        <Select
          value={meetingNotification}
          colorScheme="gray"
          onChange={val => {
            const meetingNotification = val as Array<{
              value: MeetingReminders
              label?: string
            }>
            // can't select more than 5 notifications
            if (meetingNotification.length > 5) {
              toast({
                title: 'Limit reached',
                description: 'You can select up to 5 notifications only.',
                status: 'warning',
                duration: 3000,
                isClosable: true,
              })
              return
            }
            setMeetingNotification(meetingNotification)
          }}
          className="noLeftBorder timezone-select"
          placeholder="Select Notification Alerts"
          isMulti
          tagVariant={'solid'}
          options={MeetingNotificationOptions}
          components={noClearCustomSelectComponent}
          chakraStyles={{
            container: provided => ({
              ...provided,
              borderRadius: 'md',
              maxW: '100%',
              display: 'block',
            }),

            placeholder: provided => ({
              ...provided,
              textAlign: 'left',
            }),
          }}
        />
      </FormControl>
      <FormControl
        textAlign="left"
        w="100%"
        maxW={{
          base: 'calc(100vw - 4rem)',
          md: '550px',
        }}
      >
        <FormLabel>Meeting description </FormLabel>
        <RichTextEditor
          isDisabled={isSchedulingExternal}
          placeholder="Add meeting details here"
          value={content}
          onValueChange={setContent}
        />
      </FormControl>
      {scheduleType !== undefined &&
        (selectedType?.fixed_link || !selectedType?.custom_link) && (
          <VStack alignItems="start">
            <Text fontSize="18px" fontWeight={500}>
              Location
            </Text>
            <RadioGroup
              onChange={(val: MeetingProvider) => setMeetingProvider(val)}
              value={meetingProvider}
              w={'100%'}
            >
              <VStack w={'100%'} gap={4}>
                {meetingProviders.map(provider => (
                  <Radio
                    flexDirection="row-reverse"
                    justifyContent="space-between"
                    w="100%"
                    colorScheme="primary"
                    value={provider}
                    key={provider}
                  >
                    <Text
                      fontWeight="600"
                      color={'primary.200'}
                      cursor="pointer"
                    >
                      {renderProviderName(provider)}
                    </Text>
                  </Radio>
                ))}
              </VStack>
            </RadioGroup>
            {meetingProvider === MeetingProvider.CUSTOM && (
              <Input
                type="text"
                placeholder="insert a custom meeting url"
                isDisabled={isSchedulingExternal || selectedType?.fixed_link}
                my={4}
                value={meetingUrl}
                onChange={e => setMeetingUrl(e.target.value)}
              />
            )}
            {scheduleType === SchedulingType.REGULAR &&
              (!notificationsSubs || notificationsSubs === 0) && (
                <>
                  <HStack alignItems="center">
                    <Switch
                      display="flex"
                      colorScheme="primary"
                      size="md"
                      mr={4}
                      isDisabled={isSchedulingExternal}
                      defaultChecked={doSendEmailReminders}
                      onChange={e => {
                        setSendEmailReminders(e.target.checked)
                        isUserEmailValid()
                          ? setIsFirstUserEmailValid(true)
                          : null
                      }}
                    />
                    <FormLabel mb="0">
                      <Text>Send me email reminders</Text>
                    </FormLabel>
                  </HStack>
                  {doSendEmailReminders === true && (
                    <FormControl
                      isInvalid={!isFirstUserEmailValid && !isUserEmailValid()}
                    >
                      <Input
                        type="email"
                        placeholder="Insert your email"
                        isDisabled={isSchedulingExternal}
                        value={userEmail}
                        onKeyDown={event =>
                          event.key === 'Enter' && handleConfirm()
                        }
                        onChange={e => {
                          setUserEmail(e.target.value)
                          setIsFirstUserEmailValid(false)
                        }}
                      />
                    </FormControl>
                  )}
                </>
              )}
          </VStack>
        )}
      <HStack>
        <Button
          width="full"
          flex={1}
          isDisabled={
            (scheduleType === SchedulingType.GUEST && !isGuestEmailValid()) ||
            (logged &&
              ((doSendEmailReminders && !isUserEmailValid()) || isNameEmpty)) ||
            isSchedulingExternal ||
            isGateValid === false
          }
          isLoading={isSchedulingExternal}
          onClick={
            scheduleType === SchedulingType.REGULAR
              ? handleScheduleWithWallet
              : handleConfirm
          }
          colorScheme="primary"
        >
          {getScheduleButtonLabel()}
        </Button>
        {meetingSlotId && (
          <Button
            width="full"
            flex={1}
            isDisabled={isCancelling}
            isLoading={isCancelling}
            onClick={onOpen}
            bg={'orangeButton.800'}
            color={'white'}
          >
            Cancel meeting
          </Button>
        )}
      </HStack>
    </Flex>
  )
}
